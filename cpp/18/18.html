<doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<link rel="stylesheet" href="..\styles.css">
		<link rel="stylesheet" href="styles.css">
		<link rel="stylesheet" media="screen and (max-width: 1300px)" href="..\thin.css">
		<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
		<title>Lesson 18 - Inheritance and Polymorphism I</title>
	</head>
	<body>
	<header>
		<a class="top_button" href="..\17\17.html" id="last">Last</a>
		<a class="top_button" href="..\19\19.html" id="next">Next</a>
	</header>
	<div id="main">
		<header role="banner">
			<h1>Lesson 18 - Inheritance and Polymorphism I</h1>
			<a id="home"  href="..\..\index.html">Home</a>
			<nav role="navigation">
				<ul class="subsections">
					<li><a href="#inherit">Inheritance</a></li> | 
					<li><a href="#access">Access Modifiers</a></li> | 
					<li><a href="#usagei">Using Inheritance</a></li> | 
					<li><a href="#poly">Polymorphism</a></li> | 
					<li><a href="#virt">Virtual Functions</a></li> | 
					<li><a href="#usagep">Using Polymorphism</a></li> | 
					<li><a href="#exercises">Exercises</a></li>
				</ul>
			</nav>
		</header>
		<main role="main" class="nocollapse">
			<aside role="complementary" class="example_program top">
			<h2>Example Program</h2>
			<div class="example_links">
				<a href="example.cpp" download>Download</a> | 
				<a href="http://ideone.com/XuKzPC" target="_blank">Run this Code</a>
			</div>
			<pre class="example_program prettyprint">//If you are not sure what some lines of code do, try looking back at
//previous example programs, notes, or ask a question.

#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

// our base class
class animal {
public:
	animal();
	// You're usually going to want to make descrutors virtual so the specific one will be called before the general one
	virtual ~animal();

	// Speak is virtual so subclasses can override it
	virtual void speak() const;

// inherited classes will have access to this data
protected:
	char name[10]; // example data

// inherited classes will NOT have access to private data
private:
	int ID; // example data
};

// 1st inherited class
class dog : public animal {
public:
	// normal constructor/destructor
	dog();
	// this should not be a base class, so we don't make this virtual
	~dog();

	void speak() const;

// dog can have its own private data
private:
	char color;
};

// 2nd inherited class
class cat : public animal {
public:
	// normal constructor/destructor
	cat();
	// this should not be a base class, so we don't make this virtual
	~cat();	

	void speak() const;

// cat can have its own private data
private:
	// some data
};

animal::animal()  {
	cout &lt;&lt; "animal constructor" &lt;&lt; endl;
}

animal::~animal() {
	cout &lt;&lt; "animal destructor" &lt;&lt; endl;
}

void animal::speak() const {
	cout &lt;&lt; "some animal sound" &lt;&lt; endl;
}

dog::dog() {
	cout &lt;&lt; "dog constructor" &lt;&lt; endl;
}

dog::~dog() {
	cout &lt;&lt; "dog destructor" &lt;&lt; endl;
}

void dog::speak() const {
	cout &lt;&lt; "bark!" &lt;&lt; endl;
}

cat::cat() {
	cout &lt;&lt; "cat constructor" &lt;&lt; endl;
}

cat::~cat() {
	cout &lt;&lt; "cat destructor" &lt;&lt; endl;
}

void cat::speak() const {
	cout &lt;&lt; "meow!" &lt;&lt; endl;
}


int main() {
	// polymorphism won't work
	vector&lt;animal&gt; animals;
	// polymorphism will work
	vector&lt;animal*&gt; kennel;

	cout &lt;&lt; endl &lt;&lt; "Constructing a dog:" &lt;&lt; endl;
	dog d; 
	cout &lt;&lt; endl &lt;&lt; "Constructing a cat:" &lt;&lt; endl;
	cat c; 
	cout &lt;&lt; endl &lt;&lt; "Constructing an animal:" &lt;&lt; endl;
	animal a;
	// Add stuff to animals. Here, everything gets turned into just an "animal," making polymorphism useless
	cout &lt;&lt; endl &lt;&lt; "Pass-by-value copies will be destructed as animals:" &lt;&lt; endl;
	animals.push_back(d);
	animals.push_back(c);
	animals.push_back(a);

	// Add stuff to kennel. Here, each animal retains its real type of dog or cat
	for(int index = 0; index &lt; 3; index++) {
		cout &lt;&lt; endl &lt;&lt; "Dynamically constructing a dog:" &lt;&lt; endl;
		kennel.push_back(new dog);
		cout &lt;&lt; endl &lt;&lt; "Dynamically constructing a cat:" &lt;&lt; endl;
		kennel.push_back(new cat);
	}

	// Here, all the animals will output the basic "some animal sound"
	cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "NON-POLYMORPHIC VECTOR: SPEAK" &lt;&lt; endl;
	for(int index = 0; index &lt; animals.size(); index++) {
		animals[index].speak();
	}
	cout &lt;&lt; endl;;

	// Here, all the animals will output their real "bark" or "meow"
	cout &lt;&lt; endl &lt;&lt; "POLYMORPHIC VECTOR: SPEAK" &lt;&lt; endl;
	for(int index = 0; index &lt; kennel.size(); index++) {
		kennel[index]-&gt;speak();
	}
	cout &lt;&lt; endl;

	// delete polymorphic animals
	for(int index = 0; index &lt; kennel.size(); index++) {
		cout &lt;&lt; endl &lt;&lt; "Destructing some polymorphic animal:" &lt;&lt; endl;
		delete kennel[index];
	}
	
	cout &lt;&lt; endl &lt;&lt; "Destructing static dog, cat, animal, and then non-polymorphic animal vector:" &lt;&lt; endl;
	return 0;
}</pre>
		</aside>
		<article role="article">
			<h2 id="inherit">Inheritance</h2>
			<p>
				Inheritance and polymorphism are two defining characteristics of object-oriented programming—with only what we’ve learned so far, OOP isn’t a whole lot different than procedural programming. These concepts are so defining, in fact, that if someone says they use OOP, it very often means they use inheritance and polymorphism (although the design pattern of composition is also rather popular).
			</p>
			<p>
				So, what is inheritance? Generally, it’s a way to organize classes into a hierarchy where data and logic can be shared and overridden. Specifically, one creates what’s called a “base class,” which contains the most general logic and data, creates “derived classes” which extend and modify the functionality of the base class. Some examples of this are (see: the example program) having an “animal” base class that is extended by specific classes like “dog” and “cat.” Derived classes are said to “inherit” from their base class, and the base class is called the “parent” or just the base class of its derived classes.
			</p>
			<p>
				In C++, any class can be inherited from—derived classes can themselves be used as base classes—multiple derived classes can inherit from the same base class, and a derived class can inherit from multiple base classes. 
			</p>
			<p>
				It’s common practice to diagram inheritance trees (as they’re called) like we diagramed linked trees, although here, the links represent inheritance rather than pointers. For example, one could structure the entities in a game as such:
			</p>
			<img src="tree.png" style="padding-left:10px;">
			<p>
				Inheritance can be useful in many situations—entire languages, such as Java and C#, are based off of it—but I’m not trying to say OOP is the best programming paradigm to use in any situation. Ideally, you should assess what you’re trying to do and choose whichever method will be the most effective. Some people really like OOP, some abhor it. Personally, I’d stay at a distance from <em>overly</em> complicated inheritance and polymorphism trees and logic, as I find it more effective, maintainable, and performant to use other design patterns.
			</p>
			<h2 id="access">Access Modifiers</h2>
			<p>
				We’ve already learned about the “public” and “private” keywords to specify data availability within classes. To rehash, “public” allows anything and anyone to access the method or data, and “private” allows only other member functions of that class to access the method or data.
			</p>
			<p>
				However, there is a third keyword we haven’t talked about: “protected.” Essentially, “protected” signifies that the class itself can access the data (like “private”), but derived classes may also access the data. For example, if your “animal” base class contained a “protected” name data member, all derived classes (e.g. “dog”) can access the name member as if it is a member. However, “private” data in a base class will not be accessible through a base class—still only the base class’ member functions may access it. This means that if a class has only private data, there’s likely not much point in inheriting from it, as the derived class won’t receive any of the data. 
			</p>
			<p>
				Why ever use “private” instead of “protected,” you might ask, which is a good question. Well, the most common use of “private” is to make sure that the class is not inheritable (technically, it still is, but it will not be useful to do so). Additionally, one can make sure that important data—say an encryption key—will never be messed with if someone else (or their self) extends that class and adds functionality.
			</p>
			<h2 id="usagei">Using Inheritance</h2>
			<p>
				Declaring an inherited class is quite simple in C++: simply begin like any other class with the keyword “class” and your identifier, but then add a colon, an access modifier, and your base class. 
			</p>
			<pre class="example_code prettyprint">class dog : public animal {};
class monster : protected entity {};</pre>
			<p>
				Here, the access modifier has a different meaning; it represents how the base members are interpreted within the derived class. Inheriting as “public” will change nothing about the base class’s members—public members will remain public and protected will be protected. Inheriting as “protected” will simply make the public members protected within the derived class, and the protected members will still remain protected. Finally, inheriting as “private” will make both public and protected members of the base class private within the derived class.
			</p>
			<p>
				After declaring your class as inherited, the rest of the syntax is exactly the same as we’ve learned, except that you can now use the “protected” keyword. Implementing the class is also the same, except that you can use the inherited data members and member functions. Once you’ve created your derived class, you can create it, use it, and destroy it like any other class. 
			</p>
			<pre class="example_code prettyprint">class animal
{
public:
	animal();
	~animal();
	void setname(const char* n);

private:
	char name[10];
}

class dog : public animal 
{
public:
	dog();
	~dog();
	int size;
};

int main() {
	dog derived;

	derived.size = 10;
	derived.setName(“fido”);
}</pre>
			<h2 id="poly">Polymorphism</h2>
			<p>
				Using purely inheritance allows you to extend functionality and create sub-types, but you’re still limited to using only your new derived class, and you can’t change the base functionality of the base class. Polymorphism allows you to generalize derived classes by their base class, enabling you do things such as store them under one type, generalize functionality, and customize logic. Essentially, your bass class specifies an interface that all subclasses are guaranteed to support.
			</p>
			<p>
				For example, if you created some polymorphic animals (again, see example), your base “animal” class specifies what functions will be available in all subclasses, so you can have your “dog” override the “speak” method to print “bark!,” while your “cat” can override the “speak” method to say “meow!” 
			</p>
			<p>
				Now, you can store all your “cats” and “dogs” within the same, single-typed data structure, under their shared base class “animal.” In C++, polymorphism only works using pointers/dynamic memory. This means that if you, for example, create an array that holds “animals,” all your “cats” and “dogs” will be converted to simple “animals” when added to the array, but if you create an array that holds pointers to “animals,” your “cats” and “dogs” remain “cats” and “dogs” when you add their addresses to the array. 
			</p>
			<p>See the example program.</p>
			<h2 id="virt">Virtual Functions</h2>
			<p>
				In C++, you must specifically define what member functions of a class are polymorphic and hence overrideable. This specifies that the function will be at least available in all derived classes, but it can be changed, overridden to do different things depending on the derived class. If the function exists in the derived class, even when accessing, for example, a “dog” as a general “animal,” the more specific version (“bark!”) will always be called. If the derived class doesn’t implement the function, the base class’s more general version will be called. The keyword “virtual” is used for this, and any virtual function will make the class polymorphic. 
			</p>
			<p>
				You are almost always going to want at least your base class destructor to be virtual, as this tells the program to first call the destructor of the derived class, then the destructor of the base class when an object of the derived class is destroyed. If you make another member function virtual, it works similarly to the destructor: if it is redefined within your base class, the more specific function will be called, even if you’re looking at, for example, your “dog” as simply an “animal.” However, the more general base class function will not be called afterwards.
			</p>
			<p>All of this is rather theoretical; I really encourage you to check out the example program.</p>
			<pre class="example_code prettyprint">class animal
{
public:
	animal();
	virtual ~animal();
	virtual speak();
} 

class dog : public animal
{
public:
	dog();
	~dog();
	speak();
}
 
int main() {
	dog* doge = new dog();
	animal* generalAnimal = doge;

	generalAnimal->speak();	        // Will call speak() from dog
	delete generalAnimal;	        // Will call ~dog() then ~animal()
}</pre>
			<h2 id="usagep">Using Polymorphism</h2>
			<p>
				Finally, using your polymorphic, inherited classes is no different than using normal classes – you can still use them on their own. However, with polymorphic classes, you can create data structures of general (base) data types and actually store the specific (derived) data types within them, and have the functionality be preserved. Remember, you must use pointers for the polymorphic references to work.
			</p>
			<p>See the example program, where we create an array (vector) of animals and compare it to an array of animal*s in terms of polymorphic properties.</p>
		</article>
		<section class="exercises">
			<h2 id="exercises">Programming Exercises</h2>
			<ol>
				<li>Play around with the example!</li>
				<p>Test behavior if you change what is virtual, which classes contain what data, and how they behave when combined polymorphically. Try using the animal’s name and ID, and manipulating them within the dog and cat. Try creating derived classes from “cat” or “dog.”</p>
				<li>Create your own polymorphic inheritance tree to represent some other hierarchy. For example, entities in a game, or vehicles, or employees, or more animals.</li>
			</ol>
		</section>
			<aside role="complementary" class="example_program bot">
			<h2>Example Program</h2>
			<div class="example_links">
				<a href="example.cpp" download>Download</a> | 
				<a href="http://ideone.com/XuKzPC" target="_blank">Run this Code</a>
			</div>
			<pre class="example_program prettyprint">//If you are not sure what some lines of code do, try looking back at
//previous example programs, notes, or ask a question.

#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

// our base class
class animal {
public:
	animal();
	// You're usually going to want to make descrutors virtual so the specific one will be called before the general one
	virtual ~animal();

	// Speak is virtual so subclasses can override it
	virtual void speak() const;

// inherited classes will have access to this data
protected:
	char name[10]; // example data

// inherited classes will NOT have access to private data
private:
	int ID; // example data
};

// 1st inherited class
class dog : public animal {
public:
	// normal constructor/destructor
	dog();
	// this should not be a base class, so we don't make this virtual
	~dog();

	void speak() const;

// dog can have its own private data
private:
	char color;
};

// 2nd inherited class
class cat : public animal {
public:
	// normal constructor/destructor
	cat();
	// this should not be a base class, so we don't make this virtual
	~cat();	

	void speak() const;

// cat can have its own private data
private:
	// some data
};

animal::animal()  {
	cout &lt;&lt; "animal constructor" &lt;&lt; endl;
}

animal::~animal() {
	cout &lt;&lt; "animal destructor" &lt;&lt; endl;
}

void animal::speak() const {
	cout &lt;&lt; "some animal sound" &lt;&lt; endl;
}

dog::dog() {
	cout &lt;&lt; "dog constructor" &lt;&lt; endl;
}

dog::~dog() {
	cout &lt;&lt; "dog destructor" &lt;&lt; endl;
}

void dog::speak() const {
	cout &lt;&lt; "bark!" &lt;&lt; endl;
}

cat::cat() {
	cout &lt;&lt; "cat constructor" &lt;&lt; endl;
}

cat::~cat() {
	cout &lt;&lt; "cat destructor" &lt;&lt; endl;
}

void cat::speak() const {
	cout &lt;&lt; "meow!" &lt;&lt; endl;
}


int main() {
	// polymorphism won't work
	vector&lt;animal&gt; animals;
	// polymorphism will work
	vector&lt;animal*&gt; kennel;

	cout &lt;&lt; endl &lt;&lt; "Constructing a dog:" &lt;&lt; endl;
	dog d; 
	cout &lt;&lt; endl &lt;&lt; "Constructing a cat:" &lt;&lt; endl;
	cat c; 
	cout &lt;&lt; endl &lt;&lt; "Constructing an animal:" &lt;&lt; endl;
	animal a;
	// Add stuff to animals. Here, everything gets turned into just an "animal," making polymorphism useless
	cout &lt;&lt; endl &lt;&lt; "Pass-by-value copies will be destructed as animals:" &lt;&lt; endl;
	animals.push_back(d);
	animals.push_back(c);
	animals.push_back(a);

	// Add stuff to kennel. Here, each animal retains its real type of dog or cat
	for(int index = 0; index &lt; 3; index++) {
		cout &lt;&lt; endl &lt;&lt; "Dynamically constructing a dog:" &lt;&lt; endl;
		kennel.push_back(new dog);
		cout &lt;&lt; endl &lt;&lt; "Dynamically constructing a cat:" &lt;&lt; endl;
		kennel.push_back(new cat);
	}

	// Here, all the animals will output the basic "some animal sound"
	cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "NON-POLYMORPHIC VECTOR: SPEAK" &lt;&lt; endl;
	for(int index = 0; index &lt; animals.size(); index++) {
		animals[index].speak();
	}
	cout &lt;&lt; endl;;

	// Here, all the animals will output their real "bark" or "meow"
	cout &lt;&lt; endl &lt;&lt; "POLYMORPHIC VECTOR: SPEAK" &lt;&lt; endl;
	for(int index = 0; index &lt; kennel.size(); index++) {
		kennel[index]-&gt;speak();
	}
	cout &lt;&lt; endl;

	// delete polymorphic animals
	for(int index = 0; index &lt; kennel.size(); index++) {
		cout &lt;&lt; endl &lt;&lt; "Destructing some polymorphic animal:" &lt;&lt; endl;
		delete kennel[index];
	}
	
	cout &lt;&lt; endl &lt;&lt; "Destructing static dog, cat, animal, and then non-polymorphic animal vector:" &lt;&lt; endl;
	return 0;
}</pre>
		</aside>
		</main>
		<footer role="contentinfo">
			<p>Made by Maxwell Slater &copy; 2016 | Contact me at <a href="mailto:mslater@nevada.unr.edu">mslater@nevada.unr.edu</a> | <a href="https://github.com/TheNumbat/cpp-course">View this project on GitHub</a></p>
		</footer>
	</div>
	</body>
</html>